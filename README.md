
## Описание
К сожалению в го нельзя выделять память и не инициализировать ее, тк она сразу же заполняется значением по умолчанию, поэтому подлючил библиотеку "С" для использования команд С (malloc).
Спасибо за лабараторную, появились знания об памяти виртуальной и физической.

## Описание

Программа демонстрирует разницу между виртуальной и физической памятью, механизм ленивого выделения памяти (lazy allocation) и оптимизацию Copy-on-Write в операционных системах Linux/Unix.

## Цели работы

- Изучить механизм выделения памяти через malloc
- Продемонстрировать разницу между виртуальной (VIRT) и физической (RES) памятью
- Исследовать механизм Page Fault и ленивое выделение страниц
- Сравнить производительность операций чтения и записи в память
- Наблюдать работу Copy-on-Write оптимизации

## Технические детали

# Сборка и запуск программы под Linux и Windows

Данный документ полностью описывает процесс сборки и запуска экспериментальной
программы, написанной на языке **Go** с использованием **cgo** и функций управления
памятью из стандартной C-библиотеки (`malloc`, `free`).

Программа предназначена для исследования постраничного чтения и записи памяти
и была собрана и протестирована как под **Linux**, так и под **Windows**.

# Среда сборки

Операционная система: Linux (x86_64)
Язык программирования: Go
Используемые компоненты:

- Go runtime
- cgo
- компилятор gcc
- библиотека glibc


# Процесс сборки
Сборка под Linux выполняется стандартными средствами Go без дополнительной настройки окружения.
bashgo build -o program
Параметры по умолчанию:

- GOOS=linux
- GOARCH=amd64
- CGO_ENABLED=1
- CC=gcc

# Результат сборки
Проверка типа файла:
bashfile program
Результат:
ELF 64-bit LSB executable, x86-64, for GNU/Linux


# Кросс-компиляция Windows .exe из Linux
Для запуска программы в Windows требуется исполняемый файл формата PE (Portable Executable) с расширением .exe.
Сборка такого файла выполнялась на Linux с использованием кросс-компилятора MinGW-w64.
Назначение .exe
Windows не поддерживает формат ELF, поэтому для запуска программы в этой операционной системе необходимо создать бинарник в формате PE.
Установка MinGW-w64
```bash
bashsudo apt update
sudo apt install -y gcc-mingw-w64-x86-64-posix
```
MinGW-w64 предоставляет:

C-компилятор для Windows
стандартную C-библиотеку для Windows
поддержку 64-битной архитектуры
корректный Windows ABI

Настройка окружения для кросс-компиляции
Перед сборкой Windows-бинарника задаются переменные окружения:
- bashexport CGO_ENABLED=1
- export GOOS=windows
- export GOARCH=amd64
- export CC=x86_64-w64-mingw32-gcc
Назначение переменных:

- GOOS — целевая операционная система
- GOARCH — целевая архитектура
- CC — C-компилятор для cgo
- CGO_ENABLED — включение поддержки cgo

Сборка Windows-бинарника
```bash
go build -o program.exe
```
Проверка результата
```bash
file program.exe
```
Результат:
PE32+ executable (console) x86-64, for MS Windows
Это подтверждает успешную кросс-компиляцию Windows-программы.

Запуск Windows-бинарника
Проверка под Linux с использованием Wine
Для предварительной проверки корректности работы Windows-бинарника использовалась среда Wine.
```bash
bashwine program.exe w 256
```


### htop

Для отслеживания работы программы отлично подходит утилита htop. Есть колонки вирт. и физ. памяти.
```bash
htop -p $(pgrep -d, memtest)
```

Следить за колонками:
- RES - физическая память
- VIRT - виртуальная память
- %MEM - процент от RAM

### watch + ps
```bash
watch -n 0.5 'ps aux | grep memtest | grep -v grep'
```

### /proc
```bash
watch -n 1 'cat /proc/$(pidof memtest)/status | grep -E "VmRSS|VmSize"'
```

## Выводы

### Основные результаты

**Подтверждена разница между виртуальной и физической памятью**
- malloc() выделяет виртуальную память мгновенно
- Физическая память выделяется только при обращении

**Изучен механизм работы с памятью через CGO**
- C malloc не инициализирует память
- Go GC не управляет памятью из C malloc